<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Vibe Room Simulator (Expandable Panels)</title>
    <style>
        :root {
            /* --- ë‹¤í¬ ëª¨ë“œ ê¸°ë³¸ ì„¤ì • (Sidebar/HTML) --- */
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --accent-color: #8c52ff;
            --text-color: #ffffff;
            --border-color: #333;
            --grid-color: rgba(255, 255, 255, 0.1);
            /* íŒ¨ë„ ê¸°ë³¸ ë„ˆë¹„ */
            --panel-width: 300px;
            --panel-collapsed-width: 40px;
        }
        
        body.light-mode {
            /* --- ë¼ì´íŠ¸ ëª¨ë“œ ì˜¤ë²„ë¼ì´ë“œ (Sidebar/HTML) --- */
            --bg-color: #f0f2f5;
            --panel-color: #ffffff;
            --accent-color: #6c5ce7;
            --text-color: #333333;
            --border-color: #e0e0e0;
            --grid-color: rgba(0, 0, 0, 0.1);
        }

        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Pretendard', sans-serif;
            display: flex;
            overflow: hidden;
            transition: background-color 0.3s, color 0.3s;
        }

        /* ì¢Œ/ìš° ì»¨íŠ¸ë¡¤ íŒ¨ë„ ê³µí†µ */
        .sidebar, .right-panel {
            width: var(--panel-width);
            background-color: var(--panel-color);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 10;
            transition: width 0.3s ease, background-color 0.3s, padding 0.3s;
            overflow-y: auto; 
            overflow-x: hidden;
            flex-shrink: 0; 
            position: relative; /* í† ê¸€ ë²„íŠ¼ ê¸°ì¤€ì  */
        }

        .sidebar {
            box-shadow: 4px 0 15px rgba(0,0,0,0.5);
        }

        .right-panel {
            box-shadow: -4px 0 15px rgba(0,0,0,0.5);
        }

        /* íŒ¨ë„ ì¶•ì†Œ ìƒíƒœ */
        .sidebar.collapsed {
            width: var(--panel-collapsed-width);
            padding: 20px 5px;
        }

        .right-panel.collapsed {
            width: var(--panel-collapsed-width);
            padding: 20px 5px;
        }

        /* ì¶•ì†Œ ìƒíƒœ ì‹œ ì½˜í…ì¸  ìˆ¨ê¹€ */
        .collapsed > *:not(.toggle-btn) {
            display: none;
        }

        /* ë©”ì¸ ì½˜í…ì¸  ì˜ì—­ (Canvas) */
        .main-area {
            flex: 1;
            position: relative;
            display: flex; /* ìº”ë²„ìŠ¤ ì»¨í…Œì´ë„ˆ ì—­í•  */
            overflow: hidden;
        }
        
        #mainArea canvas {
            display: block;
            width: 100% !important; 
            height: 100% !important;
        }

        /* Panel ë‚´ë¶€ ìŠ¤íƒ€ì¼ (ê¸°ì¡´ ìœ ì§€) */
        h1 { margin: 0; font-size: 20px; color: var(--accent-color); }
        h2 { margin: 0 0 10px 0; font-size: 14px; color: #888; text-transform: uppercase; }

        .control-group {
            background: color-mix(in srgb, var(--panel-color), #000000 10%);
            padding: 15px;
            border-radius: 12px;
            transition: background 0.3s;
        }
        body.light-mode .control-group {
             background: color-mix(in srgb, var(--panel-color), #000000 5%);
        }

        .input-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        label { font-size: 13px; color: var(--text-color); opacity: 0.8; }
        
        input[type="number"], select {
            background: color-mix(in srgb, var(--panel-color), #000000 15%);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 6px;
            border-radius: 4px;
            width: 100px; 
            text-align: right;
            transition: background 0.3s, border-color 0.3s;
        }
        
        select { text-align: left; width: 100%; }
        input[type="number"] { width: 60px; }


        input[type="color"] {
            background: none;
            border: none;
            width: 100%;
            height: 40px;
            cursor: pointer;
        }

        button {
            width: 100%;
            padding: 10px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            margin-top: 5px;
        }

        button:hover { filter: brightness(1.1); }
        button.outline { 
            background: transparent; 
            border: 2px solid var(--border-color); 
            color: var(--text-color); 
        }
        button.outline:hover { border-color: var(--accent-color); color: var(--accent-color); }
        
        .save-load-group button {
            width: 49%;
            margin: 0;
            display: inline-block;
        }
        .save-load-group {
            display: flex;
            justify-content: space-between;
        }
        
        /* íŒ¨ë„ ì¶•ì†Œ/í™•ì¥ ë²„íŠ¼ */
        .toggle-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 40px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            z-index: 20; 
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            padding: 0;
            border-radius: 0;
        }
        
        /* ì¢Œì¸¡ íŒ¨ë„ í† ê¸€ ë²„íŠ¼ */
        #toggleLeft {
            right: 0; 
            border-top-left-radius: 4px; 
            border-bottom-left-radius: 4px;
        }
        
        /* ìš°ì¸¡ íŒ¨ë„ í† ê¸€ ë²„íŠ¼ */
        #toggleRight {
            left: 0; 
            border-top-right-radius: 4px;
            border-bottom-right-radius: 4px;
        }

        /* --- MODAL ìŠ¤íƒ€ì¼ --- */
        #modal-container {
            display: none; 
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            backdrop-filter: blur(2px);
        }

        .modal-content {
            background-color: var(--panel-color);
            margin: 15% auto; 
            padding: 30px;
            border-radius: 12px;
            width: 350px; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            transition: all 0.3s;
        }

        .modal-content h3 {
            color: var(--accent-color);
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .modal-content .input-row {
            margin-bottom: 15px;
        }

        .modal-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        .modal-buttons button {
            width: 48%;
            margin: 0;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div class="sidebar" id="sidebar">
        <button class="toggle-btn" id="toggleLeft" onclick="togglePanel('sidebar')">
            &lt;
        </button>
        <h1>ğŸ›‹ï¸ 3D VIBE ROOM</h1>
        
        <div class="control-group">
            <h2>ë°© í¬ê¸° ì„¤ì • (ë‹¨ìœ„: M)</h2>
            <div class="input-row">
                <label>ê°€ë¡œ (W)</label>
                <input type="number" id="roomW" value="5">
            </div>
            <div class="input-row">
                <label>ì„¸ë¡œ (H)</label>
                <input type="number" id="roomH" value="3">
            </div>
            <div class="input-row">
                <label>ê¹Šì´ (D)</label>
                <input type="number" id="roomD" value="6">
            </div>
            <button class="outline" onclick="addRoom()">ğŸ  ìƒˆ ë°© ë§Œë“¤ê¸°</button>
        </div>

        <div class="control-group">
            <h2>ê°€êµ¬ ì¶”ê°€ (ë‹¨ìœ„: M)</h2>
            <div class="input-row">
                <label>ë°°ì¹˜í•  ë°© ì„ íƒ</label>
                <select id="furnitureRoomSelect"></select>
            </div>
            <hr style="border-color: var(--border-color); margin: 10px 0;">
            <div class="input-row">
                <label>ê°€ë¡œ (W)</label>
                <input type="number" id="furnW" value="1.8">
            </div>
            <div class="input-row">
                <label>ì„¸ë¡œ (H)</label> 
                <input type="number" id="furnH" value="0.5">
            </div>
            <div class="input-row">
                <label>ê¹Šì´ (D)</label>
                <input type="number" id="furnD" value="2.2">
            </div>
            <div class="input-row" style="flex-direction: column; align-items: flex-start;">
                <label style="margin-bottom:5px;">ìƒ‰ìƒ (Color)</label>
                <input type="color" id="furnColor" value="#ff7675">
            </div>
            <button onclick="addFurniture()">ê°€êµ¬ ë°°ì¹˜í•˜ê¸° (+)</button>
        </div>

        <div class="control-group">
            <h2>ğŸšª ë¬¸/ì°½ë¬¸ ë°°ì¹˜</h2>
            <div class="input-row">
                <label>ë°°ì¹˜í•  ë°© ì„ íƒ</label>
                <select id="doorRoomSelect"></select>
            </div>
            <hr style="border-color: var(--border-color); margin: 10px 0;">
            <div class="input-row">
                <label>ë¬¸ ë„ˆë¹„ (W)</label>
                <input type="number" id="doorW" value="0.9">
            </div>
            <div class="input-row">
                <label>ë²½ë©´ ì„ íƒ</label>
                <select id="doorWall">
                    <option value="+Z">ì •ë©´ (+Z)</option>
                    <option value="-Z">í›„ë©´ (-Z)</option>
                    <option value="+X">ìš°ì¸¡ë©´ (+X)</option>
                    <option value="-X">ì¢Œì¸¡ë©´ (-X)</option>
                </select>
            </div>
            <div class="input-row">
                <label>ê²½ì²©/ìŠ¤ìœ™ ì„¤ì •</label>
                <select id="doorHinge">
                    <option value="L_IN">ì™¼ìª½ ê²½ì²©, ì•ˆìœ¼ë¡œ ì—´ë¦¼</option>
                    <option value="R_IN">ì˜¤ë¥¸ìª½ ê²½ì²©, ì•ˆìœ¼ë¡œ ì—´ë¦¼</option>
                    <option value="L_OUT">ì™¼ìª½ ê²½ì²©, ë°–ìœ¼ë¡œ ì—´ë¦¼</option>
                    <option value="R_OUT">ì˜¤ë¥¸ìª½ ê²½ì²©, ë°–ìœ¼ë¡œ ì—´ë¦¼</option>
                </select>
            </div>
            <div class="input-row">
                <label>ë²½ë©´ ìœ„ì¹˜ (Offset)</label>
                <input type="number" id="doorOffset" value="0">
            </div>
            <button onclick="addDoor()">ğŸšª ë¬¸ ë°°ì¹˜í•˜ê¸° (+)</button>
        </div>
    </div>

    <div class="main-area" id="mainArea"></div>
    
    <div class="right-panel" id="right-panel">
        <button class="toggle-btn" id="toggleRight" onclick="togglePanel('right-panel')">
            &gt;
        </button>

        <div class="control-group">
            <h2>ì €ì¥ ë° ê¸°íƒ€ ê¸°ëŠ¥</h2>
            <div class="save-load-group">
                <button class="outline" onclick="loadScene()">ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸°</button>
                <button onclick="saveScene()">ğŸ’¾ í˜„ì¬ ìƒíƒœ ì €ì¥</button>
            </div>
            <button class="outline" onclick="resetScene()" style="margin-top: 10px;">ğŸ”„ ëª¨ë“  ë ˆì´ì•„ì›ƒ ì´ˆê¸°í™”</button>
            <button id="modeToggle" onclick="toggleMode()" class="outline">â˜€ï¸ Light Mode</button>
            <button onclick="captureScene()">ğŸ–¼ï¸ 3D ìº¡ì³í•˜ê¸°</button>
        </div>

        <div class="control-group" style="margin-top: auto;">
             <h2>ì¡°ì‘ TIP</h2>
            <div style="font-size: 11px; color: var(--text-color); opacity: 0.8; line-height: 1.5;">
                <p style="margin: 0 0 5px 0;">
                    **ë”ë¸”í´ë¦­**: ê°ì²´ ì†ì„± ìˆ˜ì •
                </p>
                <p style="margin: 0 0 5px 0;">
                    **Alt + Shift + ë“œë˜ê·¸**: **ë°©** ìœ„ì¹˜ ì´ë™
                </p>
                <p style="margin: 0 0 5px 0;">
                    **Shift + ë“œë˜ê·¸**: **ê°€êµ¬/ë¬¸** ìˆ˜í‰ ì´ë™
                </p>
                <p style="margin: 0;">
                    **Ctrl + ë“œë˜ê·¸**: ê°€êµ¬ ìˆ˜ì§ ì´ë™
                </p>
            </div>
        </div>
        
    </div>

    <div id="modal-container">
        <div class="modal-content">
            <h3 id="modal-title">ê°ì²´ ì†ì„± ìˆ˜ì •</h3>
            <div id="modal-body">
                </div>
            <div class="modal-buttons">
                <button class="outline" onclick="document.getElementById('modal-container').style.display='none'">ì·¨ì†Œ</button>
                <button onclick="applyModification()">ì ìš©</button>
            </div>
        </div>
    </div>
    <script>
        // --- ì „ì—­ ë³€ìˆ˜ ì„¤ì • ---
        const mainArea = document.getElementById('mainArea');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, (window.innerWidth - 600) / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true }); 
        
        renderer.setSize(mainArea.clientWidth, window.innerHeight); 
        mainArea.appendChild(renderer.domElement);
        
        let roomCounter = 0; 
        const rooms = []; 

        let selectedObjectForModal = null; // ëª¨ë‹¬ì—ì„œ ìˆ˜ì •í•  ê°ì²´ë¥¼ ì €ì¥í•˜ëŠ” ì „ì—­ ë³€ìˆ˜

        // --- íŒ¨ë„ ìƒíƒœ ê´€ë¦¬ ---
        let isSidebarCollapsed = false;
        let isRightPanelCollapsed = false;

        function updateRendererSize() {
             setTimeout(() => {
                const sidebarWidth = isSidebarCollapsed ? 40 : 300;
                const rightPanelWidth = isRightPanelCollapsed ? 40 : 300;
                const newWidth = window.innerWidth - sidebarWidth - rightPanelWidth;
                const newHeight = window.innerHeight;

                if (newWidth > 0 && newHeight > 0) {
                    renderer.setSize(newWidth, newHeight);
                    camera.aspect = newWidth / newHeight;
                    camera.updateProjectionMatrix();
                }
             }, 300); 
        }
        
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            const toggleButton = document.getElementById('toggle' + (panelId === 'sidebar' ? 'Left' : 'Right'));

            if (panelId === 'sidebar') {
                isSidebarCollapsed = !isSidebarCollapsed;
                panel.classList.toggle('collapsed', isSidebarCollapsed);
                toggleButton.innerHTML = isSidebarCollapsed ? '&gt;' : '&lt;';
            } else if (panelId === 'right-panel') {
                isRightPanelCollapsed = !isRightPanelCollapsed;
                panel.classList.toggle('collapsed', isRightPanelCollapsed);
                toggleButton.innerHTML = isRightPanelCollapsed ? '&lt;' : '&gt;';
            }
            
            updateRendererSize();
        }

        window.addEventListener('resize', updateRendererSize);
        
        // --- 3D ìƒí˜¸ì‘ìš©ì„ ìœ„í•œ ë³€ìˆ˜ ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        
        let draggableObjects = []; 
        let selectedObject = null; 
        let dragMode = null; 
        let isRoomDrag = false; 
        
        let dragYFixedPosition = 0; 
        
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0.001); 
        const offset = new THREE.Vector3();
        
        // 1. ì¡°ëª… ë° OrbitControls ì„¤ì • 
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3; 

        scene.background = new THREE.Color(0x111111);

        // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---

        function updateRoomSelect() {
            const selectFurn = document.getElementById('furnitureRoomSelect');
            const selectDoor = document.getElementById('doorRoomSelect');
            
            [selectFurn, selectDoor].forEach(select => select.innerHTML = '');

            if (rooms.length === 0) {
                const option = document.createElement('option');
                option.text = 'ë°©ì„ ë¨¼ì € ë§Œë“œì„¸ìš”';
                option.disabled = true;
                option.selected = true;
                selectFurn.appendChild(option);
                selectDoor.appendChild(option.cloneNode(true));
                return;
            }

            // Room 1, Room 2 ìˆœì„œë¡œ ì¬ì •ë ¬
            rooms.sort((a, b) => {
                const matchA = a.userData.name.match(/\d+/);
                const matchB = b.userData.name.match(/\d+/);
                const numA = matchA ? parseInt(matchA[0]) : Infinity;
                const numB = matchB ? parseInt(matchB[0]) : Infinity;
                return numA - numB;
            });
            roomCounter = rooms.length; // ì¹´ìš´í„° ì¬ì„¤ì •

            rooms.forEach(room => {
                const option = document.createElement('option');
                option.value = room.uuid;
                option.text = room.userData.name;
                selectFurn.appendChild(option.cloneNode(true));
                selectDoor.appendChild(option);
            });
        }
        
        function getRoomByUUID(uuid) {
            return rooms.find(room => room.uuid === uuid);
        }

        function toggleMode() {
            const body = document.body;
            const isLight = body.classList.toggle('light-mode');
            const button = document.getElementById('modeToggle');
            
            const lightWallHex = 0xf0f0f0; 
            const darkWallHex = 0x444444; 
            const lightSceneHex = 0xdddddd; 
            const darkSceneHex = 0x111111;  

            scene.traverse(obj => {
                if (obj.isMesh && obj.userData.isRoom) {
                    obj.material.color.setHex(isLight ? lightWallHex : darkWallHex);
                }
            });
            scene.background = new THREE.Color(isLight ? lightSceneHex : darkSceneHex);

            if (isLight) {
                button.textContent = 'ğŸŒ™ Dark Mode';
                button.classList.remove('outline');
            } else {
                button.textContent = 'â˜€ï¸ Light Mode';
                button.classList.add('outline');
            }
        }

        // 3. ìƒˆ ë°© ë§Œë“¤ê¸° (ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°ì—ì„œ ì¬ì‚¬ìš©ì„ ìœ„í•´ í•¨ìˆ˜í™”)
        function createRoomMesh(w, h, d, name, position) {
             const roomGeometry = new THREE.BoxGeometry(w, h, d);
            const initialWallHex = document.body.classList.contains('light-mode') ? 0xf0f0f0 : 0x444444;

            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: initialWallHex, 
                side: THREE.BackSide 
            });
            
            const newRoomMesh = new THREE.Mesh(roomGeometry, wallMaterial);
            newRoomMesh.position.y = h / 2;
            
            if (position) {
                 newRoomMesh.position.set(position.x, h/2, position.z);
            }

            newRoomMesh.userData = {
                isRoom: true, 
                name: name,
                width: w,
                height: h,
                depth: d
            };

            return newRoomMesh;
        }

        function addRoom() {
            const w = parseFloat(document.getElementById('roomW').value);
            const h = parseFloat(document.getElementById('roomH').value);
            const d = parseFloat(document.getElementById('roomD').value);

            if (w < 1 || h < 1 || d < 1) {
                alert("ë°© í¬ê¸°ëŠ” ìµœì†Œ 1m ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
                return;
            }

            roomCounter++;
            const roomName = `Room ${roomCounter}`;
            const newRoomMesh = createRoomMesh(w, h, d, roomName);

            // ë‹¤ìŒ ë°©ì´ ê¸°ì¡´ ë°©ê³¼ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ì„ì‹œ ì˜¤í”„ì…‹ ì ìš© (Zì¶•ìœ¼ë¡œ ì´ë™)
            if (rooms.length > 0) {
                 const lastRoom = rooms[rooms.length - 1];
                 const offsetZ = lastRoom.position.z + lastRoom.userData.depth / 2 + d / 2 + 0.5;
                 newRoomMesh.position.z = offsetZ;
            }


            scene.add(newRoomMesh);
            rooms.push(newRoomMesh);
            draggableObjects.push(newRoomMesh); 

            if (rooms.length === 1) {
                camera.position.set(w * 0.8, h * 0.5, d * 1.5);
                controls.target.set(newRoomMesh.position.x, h/2, newRoomMesh.position.z); 
                controls.update(); 
            }

            updateRoomSelect();
            alert(`${roomName}ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. Alt + Shiftë¥¼ ëˆŒëŸ¬ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`);
        }


        // 4. ê°€êµ¬ ì¶”ê°€ (ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°ì—ì„œ ì¬ì‚¬ìš©ì„ ìœ„í•´ í•¨ìˆ˜í™”)
        function createFurnitureMesh(w, h, d, color, parentUUID, position) {
            const furnGeometry = new THREE.BoxGeometry(w, h, d);
            const furnMaterial = new THREE.MeshPhongMaterial({ color: color });
            const furniture = new THREE.Mesh(furnGeometry, furnMaterial);

            if (position) {
                furniture.position.set(position.x, position.y, position.z);
            } else {
                 const targetRoom = getRoomByUUID(parentUUID);
                 if (targetRoom) {
                    furniture.position.x = targetRoom.position.x;
                    furniture.position.y = h / 2;
                    furniture.position.z = targetRoom.position.z; 
                 }
            }
            
            furniture.userData = {
                isDraggable: true,
                isDoor: false,
                baseHeight: h / 2, 
                parentRoomUUID: parentUUID,
                width: w, depth: d, height: h,
                color: color
            };

            return furniture;
        }

        function addFurniture() {
            const roomUUID = document.getElementById('furnitureRoomSelect').value;
            const targetRoom = getRoomByUUID(roomUUID);

            if (!targetRoom) {
                alert("ê°€êµ¬ë¥¼ ë°°ì¹˜í•  ë°©ì„ ì„ íƒí•˜ê±°ë‚˜, ë¨¼ì € ë°©ì„ ë§Œë“œì„¸ìš”.");
                return;
            }

            const w = parseFloat(document.getElementById('furnW').value);
            const h = parseFloat(document.getElementById('furnH').value);
            const d = parseFloat(document.getElementById('furnD').value);
            const color = document.getElementById('furnColor').value;

            if (w > targetRoom.userData.width || d > targetRoom.userData.depth || h > targetRoom.userData.height) {
                alert(`ê°€êµ¬ í¬ê¸°ê°€ ì„ íƒëœ ë°©(${targetRoom.userData.name}) í¬ê¸°ë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤!`);
                return;
            }

            const furniture = createFurnitureMesh(w, h, d, color, roomUUID);
            
            scene.add(furniture);
            draggableObjects.push(furniture);
        }

        // 5. ë¬¸ ì¶”ê°€
        function addDoor() {
            const roomUUID = document.getElementById('doorRoomSelect').value;
            const wall = document.getElementById('doorWall').value;
            const hingeType = document.getElementById('doorHinge').value; 
            const offset = parseFloat(document.getElementById('doorOffset').value);
            const w = parseFloat(document.getElementById('doorW').value);

            if (isNaN(w) || w < 0.5 || w > 2.5) {
                alert("ë¬¸ì˜ ë„ˆë¹„ëŠ” 0.5m ~ 2.5m ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤.");
                return;
            }
            if (!roomUUID) {
                alert("ë¬¸ì„ ë°°ì¹˜í•  ë°©ì„ ì„ íƒí•˜ê±°ë‚˜, ë¨¼ì € ë°©ì„ ë§Œë“œì„¸ìš”.");
                return;
            }
            
            const doorGroup = createDoorGroup(w, wall, hingeType, offset, roomUUID);
            if(doorGroup) {
                scene.add(doorGroup);
                // doorSlabì€ doorGroupì˜ ì²« ë²ˆì§¸ ìì‹
                draggableObjects.push(doorGroup.children[0]);
            }
        }


        // ë¬¸ ê·¸ë£¹ ìƒì„± (ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°ì—ì„œ ì¬ì‚¬ìš©ì„ ìœ„í•´ í•¨ìˆ˜í™”)
        function createDoorGroup(w, wall, hingeType, offset, roomUUID, position) {
             const targetRoom = getRoomByUUID(roomUUID);

             if (!targetRoom) {
                 console.error("ë¬¸ ê·¸ë£¹ ìƒì„±ì— í•„ìš”í•œ ë°© ì •ë³´ê°€ ìœ ì‹¤ë˜ì—ˆìŠµë‹ˆë‹¤.");
                 return null;
             }
             
             const h = 2.1; 
             const t = 0.05; 
             const doorGroup = new THREE.Group();
            
            // 1. Door Slab 
            const doorGeometry = new THREE.BoxGeometry(w, h, t);
            const doorMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.8 });
            const doorSlab = new THREE.Mesh(doorGeometry, doorMaterial);
            doorGroup.add(doorSlab);

            // 2. Swing Visualization 
            const swingRadius = w * 0.95; 
            const arcShape = new THREE.Shape();
            const arcGeometry = new THREE.ShapeGeometry(arcShape);
            const arcMaterial = new THREE.MeshBasicMaterial({ color: 0x88ff88, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
            const arcMesh = new THREE.Mesh(arcGeometry, arcMaterial);
            arcMesh.rotation.x = Math.PI / 2; 
            arcMesh.position.y = 0.001; 
            doorGroup.add(arcMesh);
            
            // 3. Hinge and Rotation Setup (ì¬ê³„ì‚°)
            let slabOffsetX = w / 2; 
            let rotation = 0; 
            
            if (hingeType.startsWith('R')) { slabOffsetX = -w / 2; }
            doorSlab.position.x = slabOffsetX;
            doorSlab.position.y = h / 2;

            let arcStart = 0, arcEnd = 0, arcCenter = new THREE.Vector3();

            // 4. Wall Placement and Group Rotation
            const roomW = targetRoom.userData.width;
            const roomD = targetRoom.userData.depth;
            const roomCenter = targetRoom.position;

            if (position) {
                // ë¶ˆëŸ¬ì˜¤ê¸° ì‹œ ì €ì¥ëœ ìœ„ì¹˜ ì‚¬ìš©
                doorGroup.position.set(position.x, position.y, position.z);
            } else {
                // ìƒˆë¡œ ë°°ì¹˜ ì‹œ ê³„ì‚°
                switch (wall) {
                    case '+Z': doorGroup.position.x = offset + roomCenter.x; doorGroup.position.z = roomCenter.z + roomD / 2 - t / 2; rotation = 0; break;
                    case '-Z': doorGroup.position.x = offset + roomCenter.x; doorGroup.position.z = roomCenter.z - roomD / 2 + t / 2; rotation = Math.PI; break;
                    case '+X': doorGroup.position.x = roomCenter.x + roomW / 2 - t / 2; doorGroup.position.z = offset + roomCenter.z; rotation = Math.PI / 2; break;
                    case '-X': doorGroup.position.x = roomCenter.x - roomW / 2 + t / 2; doorGroup.position.z = offset + roomCenter.z; rotation = -Math.PI / 2; break;
                }
            }

            // ìŠ¤ìœ™ ë°©í–¥ ì„¤ì •
            switch (wall) {
                case '+Z': 
                    if (hingeType === 'L_IN') { arcCenter.set(-w / 2, 0, 0); arcStart = Math.PI; arcEnd = Math.PI / 2; }
                    if (hingeType === 'R_IN') { arcCenter.set(w / 2, 0, 0); arcStart = 0; arcEnd = Math.PI / 2; }
                    if (hingeType === 'L_OUT') { arcCenter.set(-w / 2, 0, 0); arcStart = Math.PI * 2; arcEnd = Math.PI * 3 / 2; }
                    if (hingeType === 'R_OUT') { arcCenter.set(w / 2, 0, 0); arcStart = Math.PI * 3 / 2; arcEnd = Math.PI * 2; }
                    break;
                case '-Z': 
                     if (hingeType === 'L_IN') { arcCenter.set(-w / 2, 0, 0); arcStart = 0; arcEnd = Math.PI / 2; }
                    if (hingeType === 'R_IN') { arcCenter.set(w / 2, 0, 0); arcStart = Math.PI; arcEnd = Math.PI * 3 / 2; }
                    if (hingeType === 'L_OUT') { arcCenter.set(-w / 2, 0, 0); arcStart = Math.PI * 3 / 2; arcEnd = Math.PI * 2; }
                    if (hingeType === 'R_OUT') { arcCenter.set(w / 2, 0, 0); arcStart = Math.PI / 2; arcEnd = Math.PI; }
                    break;
                case '+X': 
                     if (hingeType === 'L_IN') { arcCenter.set(-w / 2, 0, 0); arcStart = Math.PI / 2; arcEnd = Math.PI; }
                    if (hingeType === 'R_IN') { arcCenter.set(w / 2, 0, 0); arcStart = 0; arcEnd = Math.PI * 3 / 2; } 
                    if (hingeType === 'L_OUT') { arcCenter.set(-w / 2, 0, 0); arcStart = Math.PI * 3 / 2; arcEnd = Math.PI * 2; }
                    if (hingeType === 'R_OUT') { arcCenter.set(w / 2, 0, 0); arcStart = Math.PI; arcEnd = Math.PI * 3 / 2; }
                    break;
                case '-X': 
                    if (hingeType === 'L_IN') { arcCenter.set(-w / 2, 0, 0); arcStart = Math.PI * 3 / 2; arcEnd = Math.PI * 2; }
                    if (hingeType === 'R_IN') { arcCenter.set(w / 2, 0, 0); arcStart = Math.PI / 2; arcEnd = Math.PI; }
                    if (hingeType === 'L_OUT') { arcCenter.set(-w / 2, 0, 0); arcStart = Math.PI; arcEnd = Math.PI / 2; }
                    if (hingeType === 'R_OUT') { arcCenter.set(w / 2, 0, 0); arcStart = Math.PI * 2; arcEnd = Math.PI * 3 / 2; }
                    break;
            }

            // ìŠ¤ìœ™ ì•„í¬ ì—…ë°ì´íŠ¸
            arcMesh.geometry.dispose();
            const arcShapeUpdated = new THREE.Shape();
            arcShapeUpdated.absarc(arcCenter.x, arcCenter.y, swingRadius, arcStart, arcEnd, hingeType.endsWith('_OUT')); 

            arcMesh.geometry = new THREE.ShapeGeometry(arcShapeUpdated);
            arcMesh.rotation.x = Math.PI / 2; 
            arcMesh.position.y = 0.001; 
            
            doorGroup.rotation.y = rotation;
            
            // ë¬¸ì§ ë©”ì‹œ (DoorSlab)ì— ì†ì„± ì €ì¥
            doorSlab.userData = {
                isDraggable: true,
                isDoor: true,
                baseWall: wall,
                doorW: w,
                doorT: t,
                doorH: h,
                parentRoomUUID: roomUUID,
                hingeType: hingeType,
                roomW: roomW, roomD: roomD 
            };
            
            return doorGroup;
        }

        // 6. ëª¨ë“  ë ˆì´ì•„ì›ƒ ì´ˆê¸°í™”
        function resetScene() {
            const objectsToRemove = scene.children.filter(obj => 
                (obj.isMesh && obj.userData.isRoom) || (obj.isMesh && obj.userData.isDraggable && !obj.userData.isDoor) || obj.isGroup
            );

            objectsToRemove.forEach(obj => {
                scene.remove(obj);
                obj.traverse(child => {
                    if (child.isMesh) {
                        if(child.geometry) child.geometry.dispose();
                        if(child.material) child.material.dispose();
                    }
                });
            });

            draggableObjects = [];
            rooms.length = 0;
            roomCounter = 0;
            
            // ì¹´ë©”ë¼ ì´ˆê¸°í™”
            camera.position.set(5, 5, 10);
            controls.target.set(0, 0, 0);
            controls.update();

            document.getElementById('roomW').value = 5;
            document.getElementById('roomH').value = 3;
            document.getElementById('roomD').value = 6;
            
            updateRoomSelect();
            alert("ëª¨ë“  ë ˆì´ì•„ì›ƒì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ìƒˆë¡œìš´ ë°©ì„ ì„¤ê³„í•´ ë³´ì„¸ìš”!");
        }
        
        // --- ìº¡ì³/ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ê¸°ëŠ¥ (ë¡œì§ ë³€ê²½ ì—†ìŒ) ---
        function captureScene() {
            try {
                renderer.render(scene, camera);
                const imageURL = renderer.domElement.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = imageURL;
                link.download = '3d_room_vibe_' + new Date().getTime() + '.png';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                alert("í˜„ì¬ 3D ì¥ë©´ì´ 'png' íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.");
            } catch (e) {
                alert("ìº¡ì³ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: " + e.message);
            }
        }
        
        function saveScene() {
            const layoutData = {
                rooms: [],
                furniture: [],
                doors: []
            };

            rooms.forEach(room => {
                layoutData.rooms.push({
                    uuid: room.uuid, name: room.userData.name, width: room.userData.width, height: room.userData.height, depth: room.userData.depth,
                    position: { x: room.position.x, y: room.position.y, z: room.position.z }
                });
            });

            draggableObjects.forEach(obj => {
                const data = obj.userData.isDoor ? obj.userData : obj.userData;
                if (data.isDoor) {
                    const doorGroup = obj.parent;
                    layoutData.doors.push({ ...data, position: { x: doorGroup.position.x, y: doorGroup.position.y, z: doorGroup.position.z } });
                } else if (data.isDraggable && !data.isRoom) {
                    layoutData.furniture.push({ ...data, position: { x: obj.position.x, y: obj.position.y, z: obj.position.z } });
                }
            });

            const dataStr = JSON.stringify(layoutData, null, 2);
            const blob = new Blob([dataStr], { type: 'text/plain' });
            
            const a = document.createElement('a');
            a.download = '3d_room_layout_' + new Date().getTime() + '.txt';
            a.href = URL.createObjectURL(blob);
            a.click();
            URL.revokeObjectURL(a.href);
            
            alert("ë ˆì´ì•„ì›ƒ ì •ë³´ê°€ í…ìŠ¤íŠ¸ íŒŒì¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
        }

        function loadScene() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';

            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        resetScene(); 
                        const uuidMap = new Map();

                        data.rooms.forEach(roomData => {
                            const newRoomMesh = createRoomMesh(roomData.width, roomData.height, roomData.depth, roomData.name, roomData.position);
                            uuidMap.set(roomData.uuid, newRoomMesh.uuid);
                            scene.add(newRoomMesh); rooms.push(newRoomMesh); draggableObjects.push(newRoomMesh);
                        });

                        data.furniture.forEach(furnData => {
                            const newParentUUID = uuidMap.get(furnData.parentRoomUUID);
                            if (!newParentUUID) return;
                            const furniture = createFurnitureMesh(furnData.width, furnData.height, furnData.depth, furnData.color, newParentUUID, furnData.position);
                            scene.add(furniture); draggableObjects.push(furniture);
                        });

                        data.doors.forEach(doorData => {
                             const newParentUUID = uuidMap.get(doorData.parentRoomUUID);
                             if (!newParentUUID) return;
                             const doorGroup = createDoorGroup(doorData.doorW, doorData.baseWall, doorData.hingeType, null, newParentUUID, doorData.position);
                             if (doorGroup) {
                                scene.add(doorGroup); draggableObjects.push(doorGroup.children[0]);
                             }
                        });

                        updateRoomSelect();
                        updateRendererSize();
                        alert("ë ˆì´ì•„ì›ƒì´ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™€ì¡ŒìŠµë‹ˆë‹¤.");

                    } catch (error) {
                        alert("íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. \n" + error.message);
                        console.error("Load Error:", error);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // --- ê°ì²´ ì†ì„± ìˆ˜ì • í•¨ìˆ˜ (ëª¨ë‹¬ ì‚¬ìš©) ---
        function generateInputHtml(label, id, value, type = 'number', step = 0.1, min = 0.1) {
            let inputHtml;
            if (type === 'color') {
                inputHtml = `<input type="color" id="${id}" value="${value}" style="width: 100px; height: 30px; padding: 0;">`;
            } else if (type === 'select') {
                const options = value.options.map(opt => 
                    `<option value="${opt.value}" ${opt.value === value.current ? 'selected' : ''}>${opt.label}</option>`
                ).join('');
                inputHtml = `<select id="${id}">${options}</select>`;
            } else {
                inputHtml = `<input type="${type}" id="${id}" value="${value.toFixed(2)}" step="${step}" min="${min}">`;
            }

            return `
                <div class="input-row">
                    <label>${label}</label>
                    ${inputHtml}
                </div>
            `;
        }

        function modifyObject(object) {
            selectedObjectForModal = object;
            const modalBody = document.getElementById('modal-body');
            const modalTitle = document.getElementById('modal-title');
            let data = object.userData.isDoor ? object.children[0].userData : object.userData;
            let htmlContent = '';

            if (data.isRoom) {
                // **ë°© (Room) ì†ì„± ìˆ˜ì •**
                modalTitle.textContent = `ğŸ  ë°© ì†ì„± ìˆ˜ì •: ${data.name}`;
                htmlContent += generateInputHtml('ê°€ë¡œ (W) m', 'modalW', data.width);
                htmlContent += generateInputHtml('ì„¸ë¡œ (H) m', 'modalH', data.height);
                htmlContent += generateInputHtml('ê¹Šì´ (D) m', 'modalD', data.depth);
            } else if (data.isDoor) {
                // **ë¬¸ (Door) ì†ì„± ìˆ˜ì •**
                modalTitle.textContent = `ğŸšª ë¬¸ ì†ì„± ìˆ˜ì •`;
                htmlContent += generateInputHtml('ë¬¸ ë„ˆë¹„ (W) m', 'modalW', data.doorW, 'number', 0.1, 0.5);
                htmlContent += generateInputHtml('ê²½ì²©/ìŠ¤ìœ™ ì„¤ì •', 'modalHinge', {
                    current: data.hingeType,
                    options: [
                        { value: 'L_IN', label: 'ì™¼ìª½ ê²½ì²©, ì•ˆìœ¼ë¡œ ì—´ë¦¼' },
                        { value: 'R_IN', label: 'ì˜¤ë¥¸ìª½ ê²½ì²©, ì•ˆìœ¼ë¡œ ì—´ë¦¼' },
                        { value: 'L_OUT', label: 'ì™¼ìª½ ê²½ì²©, ë°–ìœ¼ë¡œ ì—´ë¦¼' },
                        { value: 'R_OUT', label: 'ì˜¤ë¥¸ìª½ ê²½ì²©, ë°–ìœ¼ë¡œ ì—´ë¦¼' },
                    ]
                }, 'select');
            } else if (data.isDraggable) {
                // **ê°€êµ¬ (Furniture) ì†ì„± ìˆ˜ì •**
                modalTitle.textContent = `ğŸ›‹ï¸ ê°€êµ¬ ì†ì„± ìˆ˜ì •`;
                htmlContent += generateInputHtml('ê°€ë¡œ (W) m', 'modalW', data.width);
                htmlContent += generateInputHtml('ì„¸ë¡œ (H) m', 'modalH', data.height);
                htmlContent += generateInputHtml('ê¹Šì´ (D) m', 'modalD', data.depth);
                htmlContent += generateInputHtml('ìƒ‰ìƒ (Color)', 'modalColor', data.color, 'color');
            }

            modalBody.innerHTML = htmlContent;
            document.getElementById('modal-container').style.display = 'block';
        }

        function applyModification() {
            if (!selectedObjectForModal) return;

            const object = selectedObjectForModal;
            document.getElementById('modal-container').style.display = 'none';

            let data = object.userData.isDoor ? object.children[0].userData : object.userData;

            if (data.isRoom) {
                // ë°© ìˆ˜ì • ì ìš©
                const newW = parseFloat(document.getElementById('modalW').value);
                const newH = parseFloat(document.getElementById('modalH').value);
                const newD = parseFloat(document.getElementById('modalD').value);

                if (isNaN(newW) || isNaN(newH) || isNaN(newD) || newW < 1 || newH < 1 || newD < 1) {
                    alert("ìœ íš¨í•œ í¬ê¸°ë¥¼ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤ (ìµœì†Œ 1m).");
                    return;
                }
                
                const oldPos = object.position.clone();
                const oldUUID = object.uuid; 
                
                scene.remove(object);
                object.geometry.dispose(); object.material.dispose();
                
                const newMesh = createRoomMesh(newW, newH, newD, data.name, {x: oldPos.x, y: oldPos.y, z: oldPos.z});
                newMesh.userData.width = newW; newMesh.userData.height = newH; newMesh.userData.depth = newD;

                const roomIndex = rooms.findIndex(r => r.uuid === oldUUID);
                if (roomIndex !== -1) rooms[roomIndex] = newMesh; 
                
                draggableObjects = draggableObjects.filter(o => o !== object);
                draggableObjects.push(newMesh);
                scene.add(newMesh);
                updateRoomSelect(); 
                
            } else if (data.isDoor) {
                // ë¬¸ ìˆ˜ì • ì ìš©
                const newW = parseFloat(document.getElementById('modalW').value);
                const newHingeType = document.getElementById('modalHinge').value;

                if (isNaN(newW) || newW < 0.5 || newW > 2.5) {
                    alert("ìœ íš¨í•œ ë„ˆë¹„(0.5m ~ 2.5m)ë¥¼ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.");
                    return;
                }
                
                const doorGroup = object.parent;
                const room = getRoomByUUID(data.parentRoomUUID);

                if (!room) return; 
                
                const currentOffsetPosition = doorGroup.position.clone();
                
                scene.remove(doorGroup);
                draggableObjects = draggableObjects.filter(o => o !== object);
                doorGroup.traverse(child => { if (child.isMesh) { if(child.geometry) child.geometry.dispose(); if(child.material) child.material.dispose(); } });

                const newDoorGroup = createDoorGroup(newW, data.baseWall, newHingeType, null, room.uuid, currentOffsetPosition);
                 if (newDoorGroup) {
                    scene.add(newDoorGroup);
                    draggableObjects.push(newDoorGroup.children[0]);
                 }
                
            } else if (data.isDraggable) {
                // ê°€êµ¬ ìˆ˜ì • ì ìš©
                const newW = parseFloat(document.getElementById('modalW').value);
                const newH = parseFloat(document.getElementById('modalH').value);
                const newD = parseFloat(document.getElementById('modalD').value);
                const newColor = document.getElementById('modalColor').value;

                if (isNaN(newW) || isNaN(newH) || isNaN(newD) || newW < 0.1 || newH < 0.1 || newD < 0.1) {
                    alert("ìœ íš¨í•œ í¬ê¸°ë¥¼ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.");
                    return;
                }
                
                object.geometry.dispose(); object.material.dispose();
                object.geometry = new THREE.BoxGeometry(newW, newH, newD);
                object.material = new THREE.MeshPhongMaterial({ color: newColor || data.color });
                
                object.position.y = newH / 2;
                object.userData = { 
                    ...data, 
                    width: newW, height: newH, depth: newD,
                    baseHeight: newH / 2, color: newColor || data.color
                };
            }
            selectedObjectForModal = null;
        }
        
        // --- ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë° ë“œë˜ê·¸ ë¡œì§ (ë¡œì§ ë³€ê²½ ì—†ìŒ) ---
        function getNormalizedPointer(event) {
             const rect = renderer.domElement.getBoundingClientRect();
             const x = event.clientX - rect.left;
             const y = event.clientY - rect.top;

             const newPointer = new THREE.Vector2();
             newPointer.x = (x / rect.width) * 2 - 1; 
             newPointer.y = - (y / rect.height) * 2 + 1;
             return newPointer;
        }

        function onPointerDown(event) {
            if (event.target.closest('#modal-container') || event.target.classList.contains('toggle-btn')) return;

            isRoomDrag = event.altKey && event.shiftKey;

            if (!event.shiftKey && !event.ctrlKey && !isRoomDrag) return;

            pointer.copy(getNormalizedPointer(event));

            raycaster.setFromCamera(pointer, camera);
            
            let targets = isRoomDrag ? rooms : draggableObjects;
            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                controls.enabled = false;
                
                let mesh = intersects[0].object;
                
                if (isRoomDrag) {
                    selectedObject = mesh;
                } else if (mesh.userData.isDoor) {
                    selectedObject = mesh.parent;
                } else {
                    selectedObject = mesh;
                }

                
                let itemData = selectedObject.userData.isDoor ? selectedObject.children[0].userData : selectedObject.userData;


                if (event.ctrlKey) {
                    dragMode = 'vertical';
                } else if (event.shiftKey) {
                    dragMode = 'horizontal';
                    
                    if (isRoomDrag || !itemData.isDoor) {
                       dragYFixedPosition = selectedObject.position.y;
                    }

                    if (raycaster.ray.intersectPlane(dragPlane, offset)) {
                        offset.sub(selectedObject.position); 
                    }
                }
            }
        }

        function onPointerDrag(event) {
            if (selectedObject) {
                pointer.copy(getNormalizedPointer(event));

                let itemData = selectedObject.userData.isDoor ? selectedObject.children[0].userData : selectedObject.userData;
                let targetRoom = null;
                
                if (!isRoomDrag && itemData.parentRoomUUID) {
                    targetRoom = getRoomByUUID(itemData.parentRoomUUID);
                }


                if (dragMode === 'horizontal') {
                    raycaster.setFromCamera(pointer, camera);
                    let intersection = new THREE.Vector3();

                    if (raycaster.ray.intersectPlane(dragPlane, intersection)) {
                        let newPos = intersection.sub(offset);
                        
                        if (isRoomDrag) {
                            selectedObject.position.x = newPos.x;
                            selectedObject.position.z = newPos.z;
                            selectedObject.position.y = itemData.height / 2;
                        
                        } else if (itemData.isDoor) {
                            if (!targetRoom) return; 
                            
                            const wall = itemData.baseWall;
                            const roomCenter = targetRoom.position;
                            const roomW = targetRoom.userData.width;
                            const roomD = targetRoom.userData.depth;

                            const doorW = itemData.doorW;
                            const doorT = itemData.doorT;
                            
                            selectedObject.position.y = itemData.doorH / 2;
                            
                            if (wall === '+Z') { 
                                selectedObject.position.z = roomCenter.z + roomD / 2 - doorT / 2;
                                selectedObject.position.x = newPos.x; 
                            } else if (wall === '-Z') {
                                selectedObject.position.z = roomCenter.z - roomD / 2 + doorT / 2;
                                selectedObject.position.x = newPos.x; 
                            } else if (wall === '+X') {
                                selectedObject.position.x = roomCenter.x + roomW / 2 - doorT / 2;
                                selectedObject.position.z = newPos.z; 
                            } else if (wall === '-X') {
                                selectedObject.position.x = roomCenter.x - roomW / 2 + doorT / 2;
                                selectedObject.position.z = newPos.z; 
                            }
                            
                            if (wall === '+Z' || wall === '-Z') { 
                                const limit = roomCenter.x + roomW / 2 - doorW / 2;
                                const minLimit = roomCenter.x - roomW / 2 + doorW / 2;
                                selectedObject.position.x = Math.max(minLimit, Math.min(limit, selectedObject.position.x));
                            } else { 
                                const limit = roomCenter.z + roomD / 2 - doorW / 2;
                                const minLimit = roomCenter.z - roomD / 2 + doorW / 2;
                                selectedObject.position.z = Math.max(minLimit, Math.min(limit, selectedObject.position.z));
                            }

                        } else {
                            if (!targetRoom) return;
                            
                            selectedObject.position.copy(newPos);
                            selectedObject.position.y = dragYFixedPosition; 

                            const halfW = itemData.width / 2;
                            const halfD = itemData.depth / 2;
                            
                            const roomCenter = targetRoom.position;
                            const roomW = targetRoom.userData.width;
                            const roomD = targetRoom.userData.depth;

                            const maxX = roomCenter.x + roomW / 2 - halfW;
                            const minX = roomCenter.x - roomW / 2 + halfW;
                            const maxZ = roomCenter.z + roomD / 2 - halfD;
                            const minZ = roomCenter.z - roomD / 2 + halfD;

                            selectedObject.position.x = Math.max(minX, Math.min(maxX, selectedObject.position.x));
                            selectedObject.position.z = Math.max(minZ, Math.min(maxZ, selectedObject.position.z));
                        }
                    }
                } else if (dragMode === 'vertical') {
                    if (itemData.isDoor || isRoomDrag) return; 

                    const sensitivity = 0.01;
                    const movementY = event.movementY * -1;
                    
                    selectedObject.position.y += movementY * sensitivity;

                    let roomH = targetRoom ? targetRoom.userData.height : 3; 
                    selectedObject.position.y = Math.max(itemData.baseHeight, Math.min(roomH, selectedObject.position.y));
                }
            }
        }

        function onPointerUp() {
            if (selectedObject) {
                controls.enabled = true;
                selectedObject = null;
                dragMode = null;
                dragYFixedPosition = 0; 
                isRoomDrag = false;
            }
        }
        
        function onPointerMove(event) {
             pointer.copy(getNormalizedPointer(event));
        }

        function onDoubleClick(event) {
            if (event.target.closest('#modal-container') || event.target.classList.contains('toggle-btn')) return;

             pointer.copy(getNormalizedPointer(event));

             raycaster.setFromCamera(pointer, camera);
             
             const targets = [...rooms, ...draggableObjects]; 
             const intersects = raycaster.intersectObjects(targets);

             if (intersects.length > 0) {
                 let mesh = intersects[0].object;
                 let targetObject = mesh.userData.isDoor ? mesh.parent : mesh; 
                 
                 modifyObject(targetObject);
             }
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointerup', onPointerUp);
        renderer.domElement.addEventListener('dblclick', onDoubleClick); 

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); 
            renderer.render(scene, camera);
        }

        updateRoomSelect(); 
        updateRendererSize(); 
        animate();
    </script>
</body>
</html>
